/* THIS FILE WAS AUTO GENERATED BY codegen-maven-plugin, DO NOT EDIT IT */
package org.unidal.codegen.model.transform;

import static org.unidal.codegen.model.Constants.ATTR_KEY;
import static org.unidal.codegen.model.Constants.ATTR_MODE;
import static org.unidal.codegen.model.Constants.ATTR_NAME;
import static org.unidal.codegen.model.Constants.ATTR_NO_NAMESPACE;
import static org.unidal.codegen.model.Constants.ATTR_OP;
import static org.unidal.codegen.model.Constants.ATTR_PATH;
import static org.unidal.codegen.model.Constants.ATTR_TEMPLATE;

import org.xml.sax.Attributes;

import org.unidal.codegen.model.entity.Any;
import org.unidal.codegen.model.entity.CodegenModel;
import org.unidal.codegen.model.entity.FileModel;
import org.unidal.codegen.model.entity.ManifestModel;
import org.unidal.codegen.model.entity.NodeModel;
import org.unidal.codegen.model.entity.OutputModel;
import org.unidal.codegen.model.entity.OutputsModel;
import org.unidal.codegen.model.entity.PropertyModel;
import org.unidal.codegen.model.entity.StructureModel;

public class DefaultXmlMaker {

   public Any buildAny(Attributes attributes) {
      Any any = new Any();
      int len = attributes.getLength();

      for (int i = 0; i < len; i++) {
         String name = attributes.getQName(i);
         String value = attributes.getValue(i);

         any.setAttribute(name, value);
      }

      return any;
   }

   public CodegenModel buildCodegen(Attributes attributes) {
      CodegenModel codegen = new CodegenModel();

      return codegen;
   }

   public FileModel buildFile(Attributes attributes) {
      String path = attributes.getValue(ATTR_PATH);
      FileModel file = new FileModel();

      if (path != null) {
         file.setPath(path);
      }

      return file;
   }

   public ManifestModel buildManifest(Attributes attributes) {
      String path = attributes.getValue(ATTR_PATH);
      ManifestModel manifest = new ManifestModel();

      if (path != null) {
         manifest.setPath(path);
      }

      return manifest;
   }

   public NodeModel buildNode(Attributes attributes) {
      String name = attributes.getValue(ATTR_NAME);
      String noNamespace = attributes.getValue(ATTR_NO_NAMESPACE);
      String key = attributes.getValue(ATTR_KEY);
      NodeModel node_ = new NodeModel(name);

      if (noNamespace != null) {
         node_.setNoNamespace(convert(Boolean.class, noNamespace, null));
      }

      if (key != null) {
         node_.setKey(key);
      }

      return node_;
   }

   public OutputModel buildOutput(Attributes attributes) {
      String path = attributes.getValue(ATTR_PATH);
      String op = attributes.getValue(ATTR_OP);
      String template = attributes.getValue(ATTR_TEMPLATE);
      String mode = attributes.getValue(ATTR_MODE);
      OutputModel output = new OutputModel(path);

      if (op != null) {
         output.setOp(op);
      }

      if (template != null) {
         output.setTemplate(template);
      }

      if (mode != null) {
         output.setMode(mode);
      }

      return output;
   }

   public OutputsModel buildOutputs(Attributes attributes) {
      OutputsModel outputs = new OutputsModel();

      return outputs;
   }

   public PropertyModel buildProperty(Attributes attributes) {
      String name = attributes.getValue(ATTR_NAME);
      PropertyModel property = new PropertyModel(name);

      return property;
   }

   public StructureModel buildStructure(Attributes attributes) {
      StructureModel structure = new StructureModel();

      return structure;
   }

   @SuppressWarnings("unchecked")
   protected <T> T convert(Class<T> type, String value, T defaultValue) {
      if (value == null || value.length() == 0) {
         return defaultValue;
      }

      if (type == Boolean.class || type == Boolean.TYPE) {
         return (T) Boolean.valueOf(value);
      } else if (type == Integer.class || type == Integer.TYPE) {
         return (T) Integer.valueOf(value);
      } else if (type == Long.class || type == Long.TYPE) {
         return (T) Long.valueOf(value);
      } else if (type == Short.class || type == Short.TYPE) {
         return (T) Short.valueOf(value);
      } else if (type == Float.class || type == Float.TYPE) {
         return (T) Float.valueOf(value);
      } else if (type == Double.class || type == Double.TYPE) {
         return (T) Double.valueOf(value);
      } else if (type == Byte.class || type == Byte.TYPE) {
         return (T) Byte.valueOf(value);
      } else if (type == Character.class || type == Character.TYPE) {
         return (T) (Character) value.charAt(0);
      } else {
         return (T) value;
      }
   }
}
